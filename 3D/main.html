<html>
<head>
<style>
    canvas {
        width: 100%;
        height: 100%
    }
</style>
<script type="text/javascript" src="../dat.gui.min.js"></script>
<script type="text/javascript" src="../three.min.js"></script>
<script type="text/javascript" src="../PolyhedraData.js"></script>
<script type="text/javascript" src="../TrackballControls.js"></script>
<script type="text/javascript" src="../System.js"></script>
<script type="text/javascript" src="Line.js"></script>
<script type="text/javascript" src="Polygon.js"></script>
<script type="text/javascript" src="Polyhedron.js"></script>
<script type="text/javascript">
var D_LENGTH = 3;
var S_RADIUS = 0.125;
var E_WIDTH = 0.05;

var scene;
var camera;
var renderer;
var controls;
var mainGUI;
var collisionDetectionDialog = null;
var polyhedronControlsDialogs = [];
var polyhedronList = [];
var temporaryMeshesList = [];

function ClearPolyhedra() {
    for (var i = 0; i < polyhedronList.length; i++) {
        polyhedronList[i].Dispose();
    }
    polyhedronList = [];
}

function GetSupportedPolyhedraNames() {
    var supportedPolyhedraNames = [];
    for (var polyhedronData in PolyhedraData) {
        supportedPolyhedraNames.push(polyhedronData);
    }
    return supportedPolyhedraNames;
}

function AddPolyhedron(data, size) {
    var polyhedron = new Polyhedron(data, size);
    polyhedronList.push(polyhedron);
    polyhedronControlsDialogs.push(new PolyhedronControlsDialog(polyhedron));
    return polyhedron;
}

function ClearTemporaryMeshes() {
    for (var i = 0; i < temporaryMeshesList.length; i++) {
        scene.remove(temporaryMeshesList[i]);
    }
    temporaryMeshesList = [];
}

function ClearPolygonControlsDialogs() {
    for (var i = 0; i < polyhedronControlsDialogs.length; i++) {
        polyhedronControlsDialogs[i].Dispose();
    }
    polyhedronControlsDialogs = [];
}

function ClearScene() {
    ClearTemporaryMeshes();
    ClearPolyhedra();
    ClearPolygonControlsDialogs();
    if (collisionDetectionDialog != null) {
        collisionDetectionDialog.Dispose();
        collisionDetectionDialog = null;
    }
}

function CreateArrowMesh(start, end, thickness, height, material) {
    var direction = new THREE.Vector3().subVectors(end, start);
    direction.normalize();
    var arrowHelper = new THREE.ArrowHelper(direction, start);
    var transform = new THREE.Matrix4();
    transform.makeRotationFromQuaternion(arrowHelper.quaternion);
    transform.setPosition(new THREE.Vector3().addVectors(start, direction.setLength(height * 0.5)));
    var arrowMesh = new THREE.Mesh(new THREE.CylinderGeometry(thickness, thickness, height, 8, 4), material);
    arrowMesh.matrixAutoUpdate = false;
    arrowMesh.matrix = transform;
    arrowMesh.matrixWorldNeedsUpdate = true;
    temporaryMeshesList.push(arrowMesh);
    scene.add(arrowMesh);
}

function CreateSphereMesh(point, radius, material) {
    var sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), material);
    sphereMesh.translateX(point.x);
    sphereMesh.translateY(point.y);
    sphereMesh.translateZ(point.z);
    temporaryMeshesList.push(sphereMesh);
    scene.add(sphereMesh);
}

function CreateDividingPlane(point, normal) {
    var plane = new THREE.PlaneGeometry(20, 20, 10, 10);
    var planeMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.2}));
    planeMesh.translateX(point.x);
    planeMesh.translateY(point.y);
    planeMesh.translateZ(point.z);
    planeMesh.lookAt(normal);
    temporaryMeshesList.push(planeMesh);
    scene.add(planeMesh);
    planeMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, wireframe: true}));
    planeMesh.translateX(point.x);
    planeMesh.translateY(point.y);
    planeMesh.translateZ(point.z);
    planeMesh.lookAt(normal);
    temporaryMeshesList.push(planeMesh);
    scene.add(planeMesh);
}

function InteractiveCollisionDetection(step) {
    var numFaces = polyhedronList[0].NumFaces() + polyhedronList[1].NumFaces();

    var C0;
    var C1;
    var index;
    if (step < polyhedronList[0].NumFaces()) {
        index = step;
        C0 = polyhedronList[0];
        C1 = polyhedronList[1];
    }
    else if (step < numFaces) {
        index = step - polyhedronList[0].NumFaces();
        C0 = polyhedronList[1];
        C1 = polyhedronList[0];
    }
    else {
        index = step - numFaces;
        C0 = polyhedronList[0];
        C1 = polyhedronList[1];
    }

    ClearTemporaryMeshes();

    if (step < numFaces) {
        var face = C0.Face(index);
        if (face == undefined)
        {
            alert("step=" + step);
        }
        var P = C0.Transform(face.Centroid());
        var D = C0.Rotate(face.Normal());
        var arrowEnd = C0.Transform(new THREE.Vector3().addVectors(face.Centroid(), face.Normal()));
        CreateArrowMesh(P, arrowEnd, 0.01, D_LENGTH, new THREE.MeshBasicMaterial({color: 0xffffff}));
        var sameSide = true;
        for (var i = 0; i < C1.NumVertices(); i++) {
            var V = C1.Transform(C1.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            if (D.dot(S) > 0) {
                color = 0x3333ff;
            }
            else {
                sameSide = false;
                color = 0xff3333;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color: color}));
        }
        CreateDividingPlane(P, arrowEnd);

        if (sameSide) {
            collisionDetectionDialog.SetCollisionDetectionVeredict("non-colliding");
        }
    }
    else {
        var i = parseInt(index / C1.NumEdges());
        var j = parseInt(index % C1.NumEdges());
        var e1 = C0.Edge(i);
        var e2 = C1.Edge(j);

        CreateArrowMesh(C0.Transform(e1.GetStart()), C0.Transform(e1.GetEnd()), E_WIDTH, e1.Length(), new THREE.MeshBasicMaterial({color: 0xff00ff}));
        CreateArrowMesh(C1.Transform(e2.GetStart()), C1.Transform(e2.GetEnd()), E_WIDTH, e2.Length(), new THREE.MeshBasicMaterial({color: 0x00ffff}));
        //CreateArrowMesh(new THREE.Vector3(), new THREE.Vector3().subVectors(e1.GetEnd(), e1.GetStart()), 0.01, 1, new THREE.MeshBasicMaterial({color: 0xff00ff}));
        //CreateArrowMesh(new THREE.Vector3(), new THREE.Vector3().subVectors(e2.GetEnd(), e2.GetStart()), 0.01, 1, new THREE.MeshBasicMaterial({color: 0x00ffff}));

        var D = new THREE.Vector3().crossVectors(C0.Rotate(e1.GetDirection()), C1.Rotate(e2.GetDirection())).normalize();
        //CreateArrowMesh(new THREE.Vector3(), D, 0.01, 1, new THREE.MeshBasicMaterial({color: 0xffff00}));

        var P = C0.Transform(e1.GetStart());
        var arrowEnd = new THREE.Vector3().addVectors(P, D);
        CreateArrowMesh(P, arrowEnd, E_WIDTH, D_LENGTH, new THREE.MeshBasicMaterial({color: 0xffff00}));

        var side0 = null;
        for (var i = 0; i < C0.NumVertices(); i++) {
            var V = C0.Transform(C0.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            var dotProduct = D.dot(S);
            if (dotProduct >= 0) {
                color = 0xfff000;
            } else {
                color = 0x000fff;
            }
            if (side0 == null) {
                side0 = System.Math.Sign(dotProduct);
            }
            else if (side0 != System.Math.Sign(dotProduct)) {
                side0 = 0;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color:  color}));
        }

        var side1 = null;
        for (var i = 0; i < C1.NumVertices(); i++) {
            var V = C1.Transform(C1.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            var dotProduct = D.dot(S);
            if (dotProduct >= 0) {
                color = 0xfff000;
            } else {
                color = 0x000fff;
            }
            if (side1 == null) {
                side1 = System.Math.Sign(dotProduct);
            }
            else if (side1 != System.Math.Sign(dotProduct)) {
                side1 = 0;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color:  color}));
        }
        CreateDividingPlane(P, arrowEnd);

        if (side0 * side1 < 0) {
            collisionDetectionDialog.SetCollisionDetectionVeredict("non-colliding");
        }
    }
}

function Render() {
    renderer.render(scene, camera);
}

function Update() {
    controls.update();
}

function Animate() {
    System.AddAnimationCallback(Animate);
    Render();
    Update();
}

MainGUI = System.Object.SubClass();

MainGUI.prototype.__Constructor = function () {
    this.polyhedron = "";
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.size = 1;
    this.__selectedPolyhedronData = null;

    this.__gui = new dat.GUI();
    var controller = this.__gui.add(this, "polyhedron", [ "Select..." ].concat(GetSupportedPolyhedraNames()));
    controller.onChange(this.Polyhedron_OnChange.bind(this));
    this.__gui.add(this, "size", 0.0, 10.0);
    var positionFolder = this.__gui.addFolder("position");
    positionFolder.add(this, "x", -10.0, 10.0);
    positionFolder.add(this, "y", -10.0, 10.0);
    positionFolder.add(this, "z", -10.0, 10.0);
    this.__gui.add(this, "CreatePolyhedron");
    this.__gui.add(this, "ClearScene");
};

MainGUI.prototype.ClearScene = function () {
    ClearScene();
};

MainGUI.prototype.CreatePolyhedron = function () {
    if (this.__selectedPolyhedronData == null) {
        return;
    }

    if (this.size <= 0) {
        alert("Size cannot be equal or less than 0.");
        return;
    }

    var polyhedron = AddPolyhedron(this.__selectedPolyhedronData, this.size);
    polyhedron.SetPosition(this.x, this.y, this.z);
};

MainGUI.prototype.Polyhedron_OnChange = function (value) {
    if (value == "" || value == "Select...") {
        return;
    }

    this.__selectedPolyhedronData = PolyhedraData[value];
};

PolyhedronControlsDialog = System.Object.SubClass();

PolyhedronControlsDialog.prototype.__Constructor = function(polyhedron) {
    this.name = polyhedron.GetName();
    this.size = polyhedron.GetSize();
    this.tx = polyhedron.GetX() + 0.01;
    this.ty = polyhedron.GetY() + 0.01;
    this.tz = polyhedron.GetZ() + 0.01;
    this.rx = 0.01;
    this.ry = 0.01;
    this.rz = 0.01;
    this.__polyhedron = polyhedron;

    this.__gui = new dat.GUI();
    this.__gui.add(this, "name");
    this.__gui.add(this, "size");
    var positionFolder = this.__gui.addFolder("position");
    var controller = positionFolder.add(this, "tx", -10.0, 10.0);
    controller.onChange(this.XPositionField_OnChange.bind(this));
    controller = positionFolder.add(this, "ty", -10.0, 10.0);
    controller.onChange(this.YPositionField_OnChange.bind(this));
    controller = positionFolder.add(this, "tz", -10.0, 10.0);
    controller.onChange(this.ZPositionField_OnChange.bind(this));
    var rotationFolder = this.__gui.addFolder("rotation");
    controller = rotationFolder.add(this, "rx", 0.0, 360.0);
    controller.onChange(this.XRotationField_OnChange.bind(this));
    controller = rotationFolder.add(this, "ry", 0.0, 360.0);
    controller.onChange(this.YRotationField_OnChange.bind(this));
    controller = rotationFolder.add(this, "rz", 0.0, 360.0);
    controller.onChange(this.ZRotationField_OnChange.bind(this));
};

PolyhedronControlsDialog.prototype.XPositionField_OnChange = function(value) {
    this.tx = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.YPositionField_OnChange = function(value) {
    this.ty = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.ZPositionField_OnChange = function(value) {
    this.tz = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.XRotationField_OnChange = function(value) {
    this.rx = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.YRotationField_OnChange = function(value) {
    this.ry = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.ZRotationField_OnChange = function(value) {
    this.rz = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.Dispose = function() {
    this.__gui.destroy();
};

CollisionDetectionDialog = System.Object.SubClass();

CollisionDetectionDialog.prototype.__Constructor = function(numSteps, collisionDetectionCallback) {
    this.veredict = "unknown";
    this.step = 0;
    this.__numSteps = numSteps;
    this.__collisionDetectionCallback = collisionDetectionCallback;
    this.__gui = new dat.GUI();
    this.__veredictFieldController = this.__gui.add(this, "veredict");
    this.__stepFieldController = this.__gui.add(this, "step", 0, this.__numSteps - 1);
    this.__stepFieldController.onChange(this.StepField_OnChange.bind(this));
};

CollisionDetectionDialog.prototype.StepField_OnChange = function(value) {
    this.step = parseInt(value);
    this.__collisionDetectionCallback(this.step);
};

CollisionDetectionDialog.prototype.SetCollisionDetectionVeredict = function(collided) {
    this.veredict = collided;
    this.__veredictFieldController.updateDisplay();
};

CollisionDetectionDialog.prototype.Dispose = function() {
    this.__gui.destroy();
};

CollisionDetectionDialog.prototype.RunInteractiveCollisionDetectionAndIncrementStep = function() {
    this.__collisionDetectionCallback(this.step);
    this.step = ++this.step % this.__numSteps;
    this.__stepFieldController.updateDisplay();
};

window.onload = function () {
    document.getElementsByTagName("body")[0].onkeyup = function (e) {
        var clickEvent = e || event;
        if (clickEvent.keyCode == 32) {
            if (polyhedronList.length < 2) {
                return;
            }

            if (collisionDetectionDialog == null) {
                var numSteps = polyhedronList[0].NumFaces() + polyhedronList[1].NumFaces() + polyhedronList[0].NumEdges() * polyhedronList[1].NumEdges();
                collisionDetectionDialog = new CollisionDetectionDialog(numSteps, InteractiveCollisionDetection);
            }

            collisionDetectionDialog.RunInteractiveCollisionDetectionAndIncrementStep();
        }
    };

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 6);
    camera.lookAt(scene.position);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var light = new THREE.PointLight(0xffffff);
    light.position = camera.position;
    scene.add(light);

    controls = new THREE.TrackballControls(camera, renderer.domElement);

    mainGUI = new MainGUI();

    Animate();
};
</script>
</head>
<body>
</body>
</html>