<html>
<head>
<style>
    canvas {
        width: 100%;
        height: 100%
    }
</style>
<script type="text/javascript" src="dat.gui.min.js"></script>
<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="PolyhedraData.js"></script>
<script type="text/javascript" src="TrackballControls.js"></script>
<script type="text/javascript" src="System.js"></script>
<script type="text/javascript">
var D_LENGTH = 3;
var S_RADIUS = 0.125;
var E_WIDTH = 0.05;

var scene;
var camera;
var renderer;
var controls;
var mainGUI;
var collisionDetectionDialog = null;
var polyhedronControlsDialogs = [];
var polyhedronList = [];
var temporaryMeshesList = [];

function sign(x) { return (x >= 0) ? 1 : -1; }

Line = Object.SubClass();

Line.prototype.__Constructor = function (start, end) {
    this.__start = start;
    this.__end = end;
    this.__direction = new THREE.Vector3().subVectors(this.__end, this.__start);
    this.__length = this.__direction.length();
    this.__direction.normalize();
};

Line.prototype.GetDirection = function () {
    return this.__direction.clone();
};

Line.prototype.GetStart = function () {
    return this.__start.clone();
};

Line.prototype.GetEnd = function () {
    return this.__end.clone();
};

Line.prototype.Length = function () {
    return this.__length;
};

Polygon = Object.SubClass();

Polygon.prototype.__Constructor = function (vertices) {
    Assert.GreaterThan(vertices.length, 2);
    this.__vertices = vertices;
    this.__normal = null;
    this.__ComputeNormal();
    this.__e1 = new THREE.Vector3().subVectors(vertices[1], vertices[0]).normalize();
    this.__e2 = new THREE.Vector3().crossVectors(this.__normal, this.__e1);
    this.__origin = vertices[0];
    this.__centroid = null;
    this.__ComputeCentroid();
};

Polygon.prototype.__ComputeNormal = function () {
    this.__normal = new THREE.Vector3();
    for (var i = this.__vertices.length - 1, j = 0; j < this.__vertices.length; i = j, j++) {
        this.__normal.x += (this.__vertices[i].z + this.__vertices[j].z) * (this.__vertices[i].y - this.__vertices[j].y);
        this.__normal.y += (this.__vertices[i].x + this.__vertices[j].x) * (this.__vertices[i].z - this.__vertices[j].z);
        this.__normal.z += (this.__vertices[i].y + this.__vertices[j].y) * (this.__vertices[i].x - this.__vertices[j].x);
    }
    this.__normal.normalize();
};

Polygon.prototype.__ComputeCentroid = function () {
    var centroid = new THREE.Vector2();
    var area = 0;
    for (var i = this.__vertices.length - 1, j = 0; j < this.__vertices.length; i = j, j++) {
        var v0 = this.__ToLocalCoordinates(this.__vertices[i]);
        var v1 = this.__ToLocalCoordinates(this.__vertices[j]);
        var b = v0.x * v1.y - v1.x * v0.y;
        area += b;
        centroid.x += (v0.x + v1.x) * b;
        centroid.y += (v0.y + v1.y) * b;
    }
    area *= 0.5;
    this.__centroid = this.__ToGlobalCoordinates(centroid.divideScalar(6.0 * area));
};

Polygon.prototype.Normal = function () {
    return this.__normal;
};

Polygon.prototype.Vertex = function (i) {
    return this.__vertices[i];
};

Polygon.prototype.__ToLocalCoordinates = function (v) {
    var x = (v.x - this.__origin.x) * this.__e1.x + (v.y - this.__origin.y) * this.__e1.y + (v.z - this.__origin.z) * this.__e1.z;
    var y = (v.x - this.__origin.x) * this.__e2.x + (v.y - this.__origin.y) * this.__e2.y + (v.z - this.__origin.z) * this.__e2.z;
    return new THREE.Vector2(x, y);
};

Polygon.prototype.__ToGlobalCoordinates = function (v) {
    return new THREE.Vector3(this.__origin.x + this.__e1.x * v.x + this.__e2.x * v.y,
                    this.__origin.y + this.__e1.y * v.x + this.__e2.y * v.y,
                    this.__origin.z + this.__e1.z * v.x + this.__e2.z * v.y);
};

Polygon.prototype.Centroid = function () {
    return this.__centroid;
};

Polyhedron = Object.SubClass();

Polyhedron.prototype.__Constructor = function (data, size) {
    this.__data = data;
    this.__size = size;
    this.__vertices = [];
    this.__faces = [];
    this.__edges = [];
    this.__polyhedronMesh = null;
    this.__BuildPolyhedronMesh();
    this.__polyhedronMesh.matrixAutoUpdate = false;
    this.__polyhedronMesh.matrix = new THREE.Matrix4();
    scene.add(this.__polyhedronMesh);
};

Polyhedron.prototype.GetName = function() {
    return this.__data.name;
};

Polyhedron.prototype.GetSize = function() {
    return this.__size;
};

Polyhedron.prototype.GetX = function() {
    return this.__polyhedronMesh.matrix.elements[12];
};

Polyhedron.prototype.GetY = function() {
    return this.__polyhedronMesh.matrix.elements[13];
};

Polyhedron.prototype.GetZ = function() {
    return this.__polyhedronMesh.matrix.elements[14];
};

Polyhedron.prototype.NumEdges = function () {
    return this.__edges.length;
};

Polyhedron.prototype.NumFaces = function () {
    return this.__faces.length;
};

Polyhedron.prototype.NumVertices = function () {
    return this.__vertices.length;
};

Polyhedron.prototype.Edge = function (i) {
    return this.__edges[i];
};

Polyhedron.prototype.Face = function (i) {
    // FIXME: remove this check
    if (i >= this.__faces.length)
    {
        alert("Face() -> i(" +i+ ") >= this.__faces.length(" +this.__faces.length+ ")");
    }

    return this.__faces[i];
};

Polyhedron.prototype.Vertex = function (i) {
    return this.__vertices[i];
};

Polyhedron.prototype.Transform = function (v) {
    return v.clone().applyMatrix4(this.__polyhedronMesh.matrix);
};

Polyhedron.prototype.Rotate = function (v) {
    var rotation = new THREE.Matrix4().extractRotation(this.__polyhedronMesh.matrix);
    return v.clone().applyMatrix4(rotation);
};

Polyhedron.prototype.SetPosition = function (x, y, z) {
    this.__polyhedronMesh.matrix.setPosition(new THREE.Vector3(x, y, z));
    this.__polyhedronMesh.matrixWorldNeedsUpdate = true;
};

Polyhedron.prototype.SetRotation = function (x, y, z) {
    var quaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(x / 180 * Math.PI, y / 180 * Math.PI, z / 180 * Math.PI, "XYZ"));
    var transform = new THREE.Matrix4();
    transform.makeRotationFromQuaternion(quaternion).setPosition(new THREE.Vector3(this.GetX(), this.GetY(), this.GetZ()));
    this.__polyhedronMesh.matrix = transform;
    this.__polyhedronMesh.matrixWorldNeedsUpdate = true;
};

Polyhedron.prototype.__BuildPolyhedronMesh = function () {
    this.__polyhedronMesh = new THREE.Object3D();

    for (var i = 0; i < this.__data.vertex.length; i++) {
        this.__vertices.push(new THREE.Vector3(this.__data.vertex[i][0], this.__data.vertex[i][1], this.__data.vertex[i][2]).multiplyScalar(this.__size));
    }

    for (var i = 0; i < this.__data.vertex.length; i++) {
        var vertexMesh = new THREE.Mesh(new THREE.SphereGeometry(0.06 * this.__size, 12, 6), new THREE.MeshBasicMaterial({color: 0x333333}));
        vertexMesh.translateX(this.__vertices[i].x);
        vertexMesh.translateY(this.__vertices[i].y);
        vertexMesh.translateZ(this.__vertices[i].z);
        this.__polyhedronMesh.add(vertexMesh);
    }

    var edgeMaterial = new THREE.MeshBasicMaterial({color: 0x666666});
    var edgesMeshes = new THREE.Geometry();
    for (var i = 0; i < this.__data.edge.length; i++) {
        var start = this.__vertices[this.__data.edge[i][0]];
        var end = this.__vertices[this.__data.edge[i][1]];
        var edge = new Line(start, end);
        var direction = edge.GetDirection();
        var arrowHelper = new THREE.ArrowHelper(direction, start, edge.Length() * 0.5);
        edgesMeshes.merge(new THREE.CylinderGeometry(0.02 * this.__size, 0.02 * this.__size, edge.Length(), 8, 4),
                new THREE.Matrix4().makeRotationFromQuaternion(arrowHelper.quaternion).setPosition(new THREE.Vector3().addVectors(start, direction.multiplyScalar(edge.Length() * 0.5))), 0);
        this.__edges.push(edge);
    }
    var edgeMesh = new THREE.Mesh(edgesMeshes, edgeMaterial);
    this.__polyhedronMesh.add(edgeMesh);

    var faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors, side: THREE.FrontSide, transparent: false, opacity: 0.8 });
    var faceColors =
    {
        3: new THREE.Color(0xff0000),
        4: new THREE.Color(0x00cc00),
        5: new THREE.Color(0x0000cc),
        6: new THREE.Color(0xcccc00),
        7: new THREE.Color(0x999999),
        8: new THREE.Color(0x990099),
        9: new THREE.Color(0xff6600),
        10: new THREE.Color(0x6666ff)
    };

    var geometry = new THREE.Geometry();
    geometry.vertices = this.__vertices;
    var faceIndex = 0;
    for (var faceNum = 0; faceNum < this.__data.face.length; faceNum++) {
        for (var i = 0; i < this.__data.face[faceNum].length - 2; i++) {
            geometry.faces[faceIndex] = new THREE.Face3(this.__data.face[faceNum][0], this.__data.face[faceNum][i + 1], this.__data.face[faceNum][i + 2]);
            geometry.faces[faceIndex].color = faceColors[this.__data.face[faceNum].length];
            faceIndex++;
        }
        var faceVertices = [];
        for (var i = 0; i < this.__data.face[faceNum].length; i++) {
            faceVertices.push(this.__vertices[this.__data.face[faceNum][i]]);
        }
        this.__faces.push(new Polygon(faceVertices));
    }

    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    var faces = new THREE.Mesh(geometry, faceMaterial);
    faces.scale.multiplyScalar(1.01);
    this.__polyhedronMesh.add(faces);

    var interiorMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, vertexColors: THREE.FaceColors, side: THREE.BackSide});

    var interiorFaces = new THREE.Mesh(geometry, interiorMaterial);
    interiorFaces.scale.multiplyScalar(0.99);
    this.__polyhedronMesh.add(interiorFaces);
};

Polyhedron.prototype.Dispose = function () {
    scene.remove(this.__polyhedronMesh);
    this.__data = null;
};

function ClearPolyhedra() {
    for (var i = 0; i < polyhedronList.length; i++) {
        polyhedronList[i].Dispose();
    }
    polyhedronList = [];
}

function GetSupportedPolyhedraNames() {
    var supportedPolyhedraNames = [];
    for (var polyhedronData in PolyhedraData) {
        supportedPolyhedraNames.push(polyhedronData);
    }
    return supportedPolyhedraNames;
}

function AddPolyhedron(data, size) {
    var polyhedron = new Polyhedron(data, size);
    polyhedronList.push(polyhedron);
    polyhedronControlsDialogs.push(new PolyhedronControlsDialog(polyhedron));
    return polyhedron;
}

function ClearTemporaryMeshes() {
    for (var i = 0; i < temporaryMeshesList.length; i++) {
        scene.remove(temporaryMeshesList[i]);
    }
    temporaryMeshesList = [];
}

function ClearPolygonControlsDialogs() {
    for (var i = 0; i < polyhedronControlsDialogs.length; i++) {
        polyhedronControlsDialogs[i].Dispose();
    }
    polyhedronControlsDialogs = [];
}

function ClearScene() {
    ClearTemporaryMeshes();
    ClearPolyhedra();
    ClearPolygonControlsDialogs();
    if (collisionDetectionDialog != null) {
        collisionDetectionDialog.Dispose();
        collisionDetectionDialog = null;
    }
}

function CreateArrowMesh(start, end, thickness, height, material) {
    var direction = new THREE.Vector3().subVectors(end, start);
    direction.normalize();
    var arrowHelper = new THREE.ArrowHelper(direction, start);
    var transform = new THREE.Matrix4();
    transform.makeRotationFromQuaternion(arrowHelper.quaternion);
    transform.setPosition(new THREE.Vector3().addVectors(start, direction.setLength(height * 0.5)));
    var arrowMesh = new THREE.Mesh(new THREE.CylinderGeometry(thickness, thickness, height, 8, 4), material);
    arrowMesh.matrixAutoUpdate = false;
    arrowMesh.matrix = transform;
    arrowMesh.matrixWorldNeedsUpdate = true;
    temporaryMeshesList.push(arrowMesh);
    scene.add(arrowMesh);
}

function CreateSphereMesh(point, radius, material) {
    var sphereMesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), material);
    sphereMesh.translateX(point.x);
    sphereMesh.translateY(point.y);
    sphereMesh.translateZ(point.z);
    temporaryMeshesList.push(sphereMesh);
    scene.add(sphereMesh);
}

function CreateDividingPlane(point, normal) {
    var plane = new THREE.PlaneGeometry(20, 20, 10, 10);
    var planeMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.2}));
    planeMesh.translateX(point.x);
    planeMesh.translateY(point.y);
    planeMesh.translateZ(point.z);
    planeMesh.lookAt(normal);
    temporaryMeshesList.push(planeMesh);
    scene.add(planeMesh);
    planeMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide, wireframe: true}));
    planeMesh.translateX(point.x);
    planeMesh.translateY(point.y);
    planeMesh.translateZ(point.z);
    planeMesh.lookAt(normal);
    temporaryMeshesList.push(planeMesh);
    scene.add(planeMesh);
}

function InteractiveCollisionDetection(step) {
    var numFaces = polyhedronList[0].NumFaces() + polyhedronList[1].NumFaces();

    var C0;
    var C1;
    var index;
    if (step < polyhedronList[0].NumFaces()) {
        index = step;
        C0 = polyhedronList[0];
        C1 = polyhedronList[1];
    }
    else if (step < numFaces) {
        index = step - polyhedronList[0].NumFaces();
        C0 = polyhedronList[1];
        C1 = polyhedronList[0];
    }
    else {
        index = step - numFaces;
        C0 = polyhedronList[0];
        C1 = polyhedronList[1];
    }

    ClearTemporaryMeshes();

    if (step < numFaces) {
        var face = C0.Face(index);
        if (face == undefined)
        {
            alert("step=" + step);
        }
        var P = C0.Transform(face.Centroid());
        var D = C0.Rotate(face.Normal());
        var arrowEnd = C0.Transform(new THREE.Vector3().addVectors(face.Centroid(), face.Normal()));
        CreateArrowMesh(P, arrowEnd, 0.01, D_LENGTH, new THREE.MeshBasicMaterial({color: 0xffffff}));
        var sameSide = true;
        for (var i = 0; i < C1.NumVertices(); i++) {
            var V = C1.Transform(C1.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            if (D.dot(S) > 0) {
                color = 0x3333ff;
            }
            else {
                sameSide = false;
                color = 0xff3333;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color: color}));
        }
        CreateDividingPlane(P, arrowEnd);

        if (sameSide) {
            collisionDetectionDialog.SetCollisionDetectionVeredict("non-colliding");
        }
    }
    else {
        var i = parseInt(index / C1.NumEdges());
        var j = parseInt(index % C1.NumEdges());
        var e1 = C0.Edge(i);
        var e2 = C1.Edge(j);

        CreateArrowMesh(C0.Transform(e1.GetStart()), C0.Transform(e1.GetEnd()), E_WIDTH, e1.Length(), new THREE.MeshBasicMaterial({color: 0xff00ff}));
        CreateArrowMesh(C1.Transform(e2.GetStart()), C1.Transform(e2.GetEnd()), E_WIDTH, e2.Length(), new THREE.MeshBasicMaterial({color: 0x00ffff}));
        //CreateArrowMesh(new THREE.Vector3(), new THREE.Vector3().subVectors(e1.GetEnd(), e1.GetStart()), 0.01, 1, new THREE.MeshBasicMaterial({color: 0xff00ff}));
        //CreateArrowMesh(new THREE.Vector3(), new THREE.Vector3().subVectors(e2.GetEnd(), e2.GetStart()), 0.01, 1, new THREE.MeshBasicMaterial({color: 0x00ffff}));

        var D = new THREE.Vector3().crossVectors(C0.Rotate(e1.GetDirection()), C1.Rotate(e2.GetDirection())).normalize();
        //CreateArrowMesh(new THREE.Vector3(), D, 0.01, 1, new THREE.MeshBasicMaterial({color: 0xffff00}));

        var P = C0.Transform(e1.GetStart());
        var arrowEnd = new THREE.Vector3().addVectors(P, D);
        CreateArrowMesh(P, arrowEnd, E_WIDTH, D_LENGTH, new THREE.MeshBasicMaterial({color: 0xffff00}));

        var side0 = null;
        for (var i = 0; i < C0.NumVertices(); i++) {
            var V = C0.Transform(C0.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            var dotProduct = D.dot(S);
            if (dotProduct >= 0) {
                color = 0xfff000;
            } else {
                color = 0x000fff;
            }
            if (side0 == null) {
                side0 = sign(dotProduct);
            }
            else if (side0 != sign(dotProduct)) {
                side0 = 0;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color:  color}));
        }

        var side1 = null;
        for (var i = 0; i < C1.NumVertices(); i++) {
            var V = C1.Transform(C1.Vertex(i));
            var S = new THREE.Vector3().subVectors(V, P);
            var color;
            var dotProduct = D.dot(S);
            if (dotProduct >= 0) {
                color = 0xfff000;
            } else {
                color = 0x000fff;
            }
            if (side1 == null) {
                side1 = sign(dotProduct);
            }
            else if (side1 != sign(dotProduct)) {
                side1 = 0;
            }
            CreateSphereMesh(V, S_RADIUS, new THREE.MeshBasicMaterial({color:  color}));
        }
        CreateDividingPlane(P, arrowEnd);

        if (side0 * side1 < 0) {
            collisionDetectionDialog.SetCollisionDetectionVeredict("non-colliding");
        }
    }
}

function Render() {
    renderer.render(scene, camera);
}

function Update() {
    controls.update();
}

function Animate() {
    System.AddAnimationCallback(Animate);
    Render();
    Update();
}

MainGUI = Object.SubClass();

MainGUI.prototype.__Constructor = function () {
    this.polyhedron = "";
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.size = 1;
    this.__selectedPolyhedronData = null;

    this.__gui = new dat.GUI();
    var controller = this.__gui.add(this, "polyhedron", [ "Select..." ].concat(GetSupportedPolyhedraNames()));
    controller.onChange(this.Polyhedron_OnChange.bind(this));
    this.__gui.add(this, "size", 0.0, 10.0);
    var positionFolder = this.__gui.addFolder("position");
    positionFolder.add(this, "x", -10.0, 10.0);
    positionFolder.add(this, "y", -10.0, 10.0);
    positionFolder.add(this, "z", -10.0, 10.0);
    this.__gui.add(this, "CreatePolyhedron");
    this.__gui.add(this, "ClearScene");
};

MainGUI.prototype.ClearScene = function () {
    ClearScene();
};

MainGUI.prototype.CreatePolyhedron = function () {
    if (this.__selectedPolyhedronData == null) {
        return;
    }

    if (this.size <= 0) {
        alert("Size cannot be equal or less than 0.");
        return;
    }

    var polyhedron = AddPolyhedron(this.__selectedPolyhedronData, this.size);
    polyhedron.SetPosition(this.x, this.y, this.z);
};

MainGUI.prototype.Polyhedron_OnChange = function (value) {
    if (value == "" || value == "Select...") {
        return;
    }

    this.__selectedPolyhedronData = PolyhedraData[value];
};

PolyhedronControlsDialog = Object.SubClass();

PolyhedronControlsDialog.prototype.__Constructor = function(polyhedron) {
    this.name = polyhedron.GetName();
    this.size = polyhedron.GetSize();
    this.tx = polyhedron.GetX() + 0.01;
    this.ty = polyhedron.GetY() + 0.01;
    this.tz = polyhedron.GetZ() + 0.01;
    this.rx = 0.01;
    this.ry = 0.01;
    this.rz = 0.01;
    this.__polyhedron = polyhedron;

    this.__gui = new dat.GUI();
    this.__gui.add(this, "name");
    this.__gui.add(this, "size");
    var positionFolder = this.__gui.addFolder("position");
    var controller = positionFolder.add(this, "tx", -10.0, 10.0);
    controller.onChange(this.XPositionField_OnChange.bind(this));
    controller = positionFolder.add(this, "ty", -10.0, 10.0);
    controller.onChange(this.YPositionField_OnChange.bind(this));
    controller = positionFolder.add(this, "tz", -10.0, 10.0);
    controller.onChange(this.ZPositionField_OnChange.bind(this));
    var rotationFolder = this.__gui.addFolder("rotation");
    controller = rotationFolder.add(this, "rx", 0.0, 360.0);
    controller.onChange(this.XRotationField_OnChange.bind(this));
    controller = rotationFolder.add(this, "ry", 0.0, 360.0);
    controller.onChange(this.YRotationField_OnChange.bind(this));
    controller = rotationFolder.add(this, "rz", 0.0, 360.0);
    controller.onChange(this.ZRotationField_OnChange.bind(this));
};

PolyhedronControlsDialog.prototype.XPositionField_OnChange = function(value) {
    this.tx = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.YPositionField_OnChange = function(value) {
    this.ty = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.ZPositionField_OnChange = function(value) {
    this.tz = parseFloat(value);
    this.__polyhedron.SetPosition(this.tx, this.ty, this.tz);
};

PolyhedronControlsDialog.prototype.XRotationField_OnChange = function(value) {
    this.rx = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.YRotationField_OnChange = function(value) {
    this.ry = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.ZRotationField_OnChange = function(value) {
    this.rz = parseFloat(value);
    this.__polyhedron.SetRotation(this.rx, this.ry, this.rz);
};

PolyhedronControlsDialog.prototype.Dispose = function() {
    this.__gui.destroy();
};

CollisionDetectionDialog = Object.SubClass();

CollisionDetectionDialog.prototype.__Constructor = function(numSteps) {
    this.veredict = "unknown";
    this.step = 0;
    this.__numSteps = numSteps;
    this.__gui = new dat.GUI();
    this.__veredictFieldController = this.__gui.add(this, "veredict");
    this.__stepFieldController = this.__gui.add(this, "step", 0, this.__numSteps - 1);
    this.__stepFieldController.onChange(this.StepField_OnChange.bind(this));
};

CollisionDetectionDialog.prototype.StepField_OnChange = function(value) {
    this.step = parseInt(value);
    InteractiveCollisionDetection(this.step);
};

CollisionDetectionDialog.prototype.SetCollisionDetectionVeredict = function(collided) {
    this.veredict = collided;
    this.__veredictFieldController.updateDisplay();
};

CollisionDetectionDialog.prototype.Dispose = function() {
    this.__gui.destroy();
};

CollisionDetectionDialog.prototype.RunInteractiveCollisionDetectionAndIncrementStep = function() {
    InteractiveCollisionDetection(this.step);
    this.step = ++this.step % this.__numSteps;
    this.__stepFieldController.updateDisplay();
};

window.onload = function () {
    document.getElementsByTagName("body")[0].onkeyup = function (e) {
        var clickEvent = e || event;
        if (clickEvent.keyCode == 32) {
            if (polyhedronList.length < 2) {
                return;
            }

            if (collisionDetectionDialog == null) {
                collisionDetectionDialog = new CollisionDetectionDialog(polyhedronList[0].NumFaces() + polyhedronList[1].NumFaces() + polyhedronList[0].NumEdges() * polyhedronList[1].NumEdges());
            }

            collisionDetectionDialog.RunInteractiveCollisionDetectionAndIncrementStep();
        }
    };

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 6);
    camera.lookAt(scene.position);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var light = new THREE.PointLight(0xffffff);
    light.position = camera.position;
    scene.add(light);

    controls = new THREE.TrackballControls(camera, renderer.domElement);

    mainGUI = new MainGUI();

    Animate();
};
</script>
</head>
<body>
</body>
</html>